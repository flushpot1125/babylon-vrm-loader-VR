!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r(require("@babylonjs/core/Maths/math"),require("@babylonjs/loaders/glTF/2.0"),require("@babylonjs/core/Engines/engine"),require("@babylonjs/core/Loading/sceneLoader"),require("@babylonjs/loaders/glTF/glTFFileLoader"),require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/effectFallbacks"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines")):"function"==typeof define&&define.amd?define(["@babylonjs/core/Maths/math","@babylonjs/loaders/glTF/2.0","@babylonjs/core/Engines/engine","@babylonjs/core/Loading/sceneLoader","@babylonjs/loaders/glTF/glTFFileLoader","@babylonjs/core/Misc/decorators","@babylonjs/core/Misc/iInspectable","@babylonjs/core/Materials/materialHelper","@babylonjs/core/Materials/effect","@babylonjs/core/Materials/material","@babylonjs/core/Meshes/buffer","@babylonjs/core/Engines/constants","@babylonjs/core/sceneComponent","@babylonjs/core/Materials/effectFallbacks","@babylonjs/core/Materials/pushMaterial","@babylonjs/core/scene","@babylonjs/core/Materials/materialDefines"],r):"object"==typeof exports?exports["babylon-vrm-loader"]=r(require("@babylonjs/core/Maths/math"),require("@babylonjs/loaders/glTF/2.0"),require("@babylonjs/core/Engines/engine"),require("@babylonjs/core/Loading/sceneLoader"),require("@babylonjs/loaders/glTF/glTFFileLoader"),require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/effectFallbacks"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines")):e["babylon-vrm-loader"]=r(e["@babylonjs/core/Maths/math"],e["@babylonjs/loaders/glTF/2.0"],e["@babylonjs/core/Engines/engine"],e["@babylonjs/core/Loading/sceneLoader"],e["@babylonjs/loaders/glTF/glTFFileLoader"],e["@babylonjs/core/Misc/decorators"],e["@babylonjs/core/Misc/iInspectable"],e["@babylonjs/core/Materials/materialHelper"],e["@babylonjs/core/Materials/effect"],e["@babylonjs/core/Materials/material"],e["@babylonjs/core/Meshes/buffer"],e["@babylonjs/core/Engines/constants"],e["@babylonjs/core/sceneComponent"],e["@babylonjs/core/Materials/effectFallbacks"],e["@babylonjs/core/Materials/pushMaterial"],e["@babylonjs/core/scene"],e["@babylonjs/core/Materials/materialDefines"])}(window,(function(e,r,t,i,n,o,a,s,l,f,d,u,h,c,p,m,v){return function(e){var r={};function t(i){if(r[i])return r[i].exports;var n=r[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=r,t.d=function(e,r,i){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)t.d(i,n,function(r){return e[r]}.bind(null,n));return i},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=18)}([function(r,t){r.exports=e},function(e,t){e.exports=r},function(e,r){e.exports=t},function(e,r,t){var i,n,o,a,s,l,f,d,u,h,c,p,m;window,e.exports=(i=t(6),n=t(7),o=t(8),a=t(9),s=t(0),l=t(10),f=t(11),d=t(12),u=t(13),h=t(14),c=t(15),p=t(16),m=t(17),function(e){var r={};function t(i){if(r[i])return r[i].exports;var n=r[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=r,t.d=function(e,r,i){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)t.d(i,n,function(r){return e[r]}.bind(null,n));return i},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=20)}([function(e,r){e.exports=i},function(e,r){e.exports=n},function(e,r){e.exports=o},function(e,r){e.exports=a},function(e,r){e.exports=s},function(e,r){e.exports=l},function(e,r){e.exports=f},function(e,r){e.exports=d},function(e,r){e.exports=u},function(e,r){e.exports=h},function(e,r){e.exports=c},function(e,r){e.exports=p},function(e,r){e.exports=m},function(e,r,t){"use strict";t.r(r),r.default="// include<__decl__mtoonVertex> または include<__decl__mtoonFragment> と書いた時に WebGL2 の場合展開される\r\n// @see effect.ts\r\n\r\nlayout(std140, column_major) uniform;\r\n\r\nuniform Material\r\n{\r\n    // Color & Texture\r\n    vec4 vDiffuseColor;\r\n    vec2 vDiffuseInfos;\r\n    mat4 diffuseMatrix;\r\n    vec4 vEmissiveColor;\r\n    vec2 vEmissiveInfos;\r\n    mat4 emissiveMatrix;\r\n    vec3 vBumpInfos;\r\n    mat4 bumpMatrix;\r\n    vec3 vShadeColor;\r\n    vec2 vShadeInfos;\r\n    mat4 shadeMatrix;\r\n    vec2 vReceiveShadowInfos;\r\n    mat4 receiveShadowMatrix;\r\n    vec2 vShadingGradeInfos;\r\n    mat4 shadingGradeMatrix;\r\n    vec3 vRimColor;\r\n    vec2 vRimInfos;\r\n    mat4 rimMatrix;\r\n    vec2 vMatCapInfos;\r\n    mat4 matCapMatrix;\r\n    vec4 vOutlineColor;\r\n    vec2 vOutlineWidthInfos;\r\n    mat4 outlineWidthMatrix;\r\n    vec2 vUvAnimationMaskInfos;\r\n    mat4 uvAnimationMaskMatrix;\r\n\r\n    // babylon specific\r\n    vec2 vTangentSpaceParams;\r\n    float pointSize;\r\n    float visibility;\r\n\r\n    // MToon params\r\n    float shadingGradeRate;\r\n    float receiveShadowRate;\r\n    float shadeShift;\r\n    float shadeToony;\r\n    float lightColorAttenuation;\r\n    float indirectLightIntensity;\r\n    float rimLightingMix;\r\n    float rimFresnelPower;\r\n    float rimLift;\r\n    float outlineWidth;\r\n    float outlineScaledMaxDistance;\r\n    float outlineLightingMix;\r\n    float uvAnimationScrollX;\r\n    float uvAnimationScrollY;\r\n    float uvAnimationRotation;\r\n};\r\n\r\n// babylon specific\r\nuniform Scene {\r\n    mat4 viewProjection;\r\n#ifdef MULTIVIEW\r\n    mat4 viewProjectionR;\r\n#endif\r\n    mat4 view;\r\n};\r\n"},function(e,r,t){"use strict";t.r(r),r.default="// Uniforms\r\nuniform mat4 viewProjection;\r\nuniform mat4 view;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float outlineLightingMix;\r\n\r\n#ifdef DIFFUSE\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\nuniform mat4 shadeMatrix;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\nuniform mat4 receiveShadowMatrix;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\nuniform mat4 shadingGradeMatrix;\r\n#endif\r\n\r\n#ifdef RIM\r\nuniform vec2 vRimInfos;\r\nuniform mat4 rimMatrix;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\nuniform mat4 matCapMatrix;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\nuniform mat4 outlineWidthMatrix;\r\n#endif\r\n\r\n#ifdef UV_ANIMATION_MASK\r\nuniform vec2 vUvAnimationMaskInfos;\r\nuniform mat4 uvAnimationMaskMatrix;\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n"},function(e,r,t){"use strict";t.r(r),r.default="uniform mat4 viewProjection;\r\nuniform mat4 view;\r\nuniform float visibility;\r\n\r\n// Colors\r\nuniform vec4 vDiffuseColor;\r\nuniform vec3 vEmissiveColor;\r\nuniform vec3 vShadeColor;\r\nuniform vec3 vRimColor;\r\nuniform vec4 vOutlineColor;\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform vec2 vTangentSpaceParams;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\n#endif\r\n\r\n#ifdef RIM\r\nuniform vec2 vRimInfos;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\n#endif\r\n\r\n#ifdef UV_ANIMATION_MASK\r\nuniform vec2 vUvAnimationMaskInfos;\r\n#endif\r\n\r\n// MToon params\r\nuniform float shadingGradeRate;\r\nuniform float receiveShadowRate;\r\nuniform float shadeShift;\r\nuniform float shadeToony;\r\nuniform float lightColorAttenuation;\r\nuniform float indirectLightIntensity;\r\nuniform float rimLightingMix;\r\nuniform float rimFresnelPower;\r\nuniform float rimLift;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float outlineLightingMix;\r\nuniform float uvAnimationScrollX;\r\nuniform float uvAnimationScrollY;\r\nuniform float uvAnimationRotation;\r\n"},function(e,r,t){"use strict";t.r(r),r.default="// replace vBumpUV to mainUv\r\nvec2 uvOffset = vec2(0.0, 0.0);\r\n\r\n#if defined(BUMP) || defined(PARALLAX)\r\n\t#ifdef NORMALXYSCALE\r\n\t\tfloat normalScale = 1.0;\r\n\t#else\r\n\t\tfloat normalScale = vBumpInfos.y;\r\n\t#endif\r\n\r\n\t#if defined(TANGENT) && defined(NORMAL)\r\n\t\tmat3 TBN = vTBN;\r\n\t#else\r\n\t\tmat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, mainUv);\r\n\t#endif\r\n#elif defined(ANISOTROPIC)\r\n\t#if defined(TANGENT) && defined(NORMAL)\r\n\t\tmat3 TBN = vTBN;\r\n\t#else\r\n\t\tmat3 TBN = cotangent_frame(normalW, vPositionW, vMainUV1, vec2(1., 1.));\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PARALLAX\r\n\tmat3 invTBN = transposeMat3(TBN);\r\n\r\n\t#ifdef PARALLAXOCCLUSION\r\n\t\tuvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\r\n\t#else\r\n\t\tuvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\r\n\t#endif\r\n#endif\r\n\r\n#ifdef BUMP\r\n\t#ifdef OBJECTSPACE_NORMALMAP\r\n\t\tnormalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\r\n\t\tnormalW = normalize(mat3(normalMatrix) * normalW);\r\n\t#else\r\n\t\tnormalW = perturbNormal(TBN, mainUv + uvOffset);\r\n\t#endif\r\n#endif\r\n"},function(e,r,t){"use strict";t.r(r),r.default="#ifdef LIGHT{X}\r\n    #ifdef SHADOW{X}\r\n        #ifdef SHADOWCLOSEESM{X}\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWESM{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPOISSON{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCF{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCSS{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #else\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #endif\r\n    #else\r\n        shadow = 1.;\r\n    #endif\r\n\r\n    // ここで MToon のライティングを適用\r\n    #ifdef SPOTLIGHT{X}\r\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\r\n    #elif defined(HEMILIGHT{X})\r\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\r\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\r\n        lightDirection = computeLightDirection(light{X}.vLightData);\r\n    #endif\r\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\r\n    diffuseBase += mtoonDiffuse.rgb;\r\n    alpha = min(alpha, mtoonDiffuse.a);\r\n    #ifdef ALPHATEST\r\n        if (alpha < alphaCutOff) {\r\n            discard;\r\n        }\r\n    #endif\r\n#endif\r\n"},function(e,r,t){"use strict";t.r(r),r.default="// この include は特別で、 UboDeclaration または VertexDeclaration のどちらかに置換される\r\n// @see effect.ts\r\n#include<__decl__mtoonVertex>\r\n\r\n// 基本的に default.vertex.fx を踏襲している\r\n\r\n// Attributes\r\n\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef TANGENT\r\nattribute vec4 tangent;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n\r\n#include<helperFunctions>\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\n#ifdef MAINUV1\r\nvarying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\nvarying vec2 vMainUV2;\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\nvarying vec2 vDiffuseUV;\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\nvarying vec2 vEmissiveUV;\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\nvarying vec2 vBumpUV;\r\n#endif\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#include<bumpVertexDeclaration>\r\n\r\n#include<clipPlaneVertexDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<morphTargetsVertexGlobalDeclaration>\r\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<logDepthDeclaration>\r\n\r\n\r\n// Additional Uniforms\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    varying vec2 vShadeUV;\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    varying vec2 vReceiveShadowUV;\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    varying vec2 vShadingGradeUV;\r\n#endif\r\n#if defined(RIM) && RIMDIRECTUV == 0\r\n    varying vec2 vRimUV;\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    varying vec2 vMatCapUV;\r\n#endif\r\n#if defined(OUTLINE_WIDTH) && OUTLINE_WIDTHDIRECTUV == 0\r\n    varying vec2 vOutlineWidthUV;\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    uniform sampler2D outlineWidthSampler;\r\n#endif\r\n#if defined(UV_ANIMATION_MASK) && UV_ANIMATION_MASKDIRECTUV == 0\r\n    varying vec2 vUvAnimationMaskUV;\r\n#endif\r\n\r\nuniform float aspect;\r\nuniform float isOutline;\r\n\r\nvoid main(void) {\r\n\r\n    vec3 positionUpdated = position;\r\n#ifdef NORMAL\r\n    vec3 normalUpdated = normal;\r\n#endif\r\n#ifdef TANGENT\r\n    vec4 tangentUpdated = tangent;\r\n#endif\r\n\r\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n    // Texture coordinates\r\n#ifndef UV1\r\n    vec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n    vec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    vMainUV1 = uv;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    vMainUV2 = uv2;\r\n#endif\r\n\r\n    float outlineTex = 1.0;\r\n    if (isOutline == 1.0) {\r\n#ifdef OUTLINE_WIDTH\r\n    #if OUTLINE_WIDTHDIRECTUV == 0\r\n        if (vOutlineWidthInfos.x == 0.) {\r\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv, 1.0, 0.0));\r\n        } else {\r\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\r\n        }\r\n    #elif defined(MAINUV1)\r\n        vec2 vOutlineWidthUV = vMainUV1;\r\n    #elif defined(MAINUV2)\r\n        vec2 vOutlineWidthUV = vMainUV2;\r\n    #else\r\n        vec2 vOutlineWidthUV = vec2(0., 0.);\r\n    #endif\r\n    outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\r\n#endif\r\n\r\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\r\n        // ワールド座標の normal 分だけ移動する\r\n        vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\r\n        positionUpdated.xyz += outlineOffset;\r\n#endif\r\n    } // End isOutline == 1.0\r\n\r\n    vec4 vertex = vec4(1.0);\r\n#ifdef MULTIVIEW\r\n    if (gl_ViewID_OVR == 0u) {\r\n        vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n    } else {\r\n        vertex = viewProjectionR * finalWorld * vec4(positionUpdated, 1.0);\r\n    }\r\n#else\r\n    vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n#endif\r\n\r\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\r\n    if (isOutline == 1.0) {\r\n        vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\r\n        projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\r\n        projectedNormal.x *= aspect;\r\n        vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy * clamp(1.0 - abs(normalize(view * vec4(normalUpdated, 1.0)).z), 0.0, 1.0); // ignore offset when normal toward camera\r\n    }\r\n#endif\r\n\r\n    if (isOutline == 1.0) {\r\n        vertex.z += 1E-2 * vertex.w; // anti-artifact magic from three-vrm\r\n    }\r\n\r\n    gl_Position = vertex;\r\n\r\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n    vPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\n    mat3 normalWorld = mat3(finalWorld);\r\n\r\n    #ifdef NONUNIFORMSCALING\r\n        normalWorld = transposeMat3(inverseMat3(normalWorld));\r\n    #endif\r\n\r\n    vNormalW = normalize(normalWorld * normalUpdated);\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\n    if (vDiffuseInfos.x == 0.)\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\n    if (vEmissiveInfos.x == 0.)\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\n    if (vBumpInfos.x == 0.)\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    if (vShadeInfos.x == 0.) {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    if (vReceiveShadowInfos.x == 0.) {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    if (vShadingGradeInfos.x == 0.) {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(RIM) && RIMDIRECTUV == 0\r\n    if (vRimInfos.x == 0.) {\r\n        vRimUV = vec2(rimMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vRimUV = vec2(rimMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    if (vMatCapInfos.x == 0.) {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(UV_ANIMATION_MASK) && UV_ANIMATION_MASKDIRECTUV == 0\r\n    if (vUvAnimationMaskInfos.x == 0.) {\r\n        vUvAnimationMaskUV = vec2(uvAnimationMaskMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vUvAnimationMaskUV = vec2(uvAnimationMaskMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#include<bumpVertex>\r\n#include<clipPlaneVertex>\r\n#include<fogVertex>\r\n#include<shadowsVertex>[0..maxSimultaneousLights]\r\n\r\n#include<pointCloudVertex>\r\n#include<logDepthVertex>\r\n\r\n}\r\n"},function(e,r,t){"use strict";t.r(r),r.default="#include<__decl__mtoonFragment>\r\n\r\n#if defined(BUMP) || !defined(NORMAL)\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\n#ifdef LOGARITHMICDEPTH\r\n#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\n// Constants\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define PI_2 6.28318530718\r\n#define EPS_COL 0.00001\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vEyeUp;\r\nuniform vec3 vAmbientColor;\r\nuniform float aspect;\r\nuniform float isOutline;\r\nuniform vec4 time;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    varying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    varying vec2 vMainUV2;\r\n#endif\r\n\r\n// Helper functions\r\n#include<helperFunctions>\r\n\r\n// Lights\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<lightsFragmentFunctions>\r\n#include<shadowsFragmentFunctions>\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\n    #if DIFFUSEDIRECTUV == 1\r\n        #define vDiffuseUV vMainUV1\r\n    #elif DIFFUSEDIRECTUV == 2\r\n        #define vDiffuseUV vMainUV2\r\n    #else\r\n        varying vec2 vDiffuseUV;\r\n    #endif\r\n    uniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n    #if EMISSIVEDIRECTUV == 1\r\n        #define vEmissiveUV vMainUV1\r\n    #elif EMISSIVEDIRECTUV == 2\r\n        #define vEmissiveUV vMainUV2\r\n    #else\r\n        varying vec2 vEmissiveUV;\r\n    #endif\r\n    uniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n     uniform float alphaCutOff;\r\n#endif\r\n\r\n#ifdef SHADE\r\n    uniform sampler2D shadeSampler;\r\n    #if SHADEDIRECTUV == 1\r\n        #define vShadeUV vMainUV1\r\n    #elif SHADEDIRECTUV == 2\r\n        #define vShadeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadeUV;\r\n    #endif\r\n#endif\r\n#ifdef RECEIVE_SHADOW\r\n    uniform sampler2D receiveShadowSampler;\r\n    #if RECEIVE_SHADOWDIRECTUV == 1\r\n        #define vReceiveShadowUV vMainUV1\r\n    #elif RECEIVE_SHADOWDIRECTUV == 2\r\n        #define vReceiveShadowUV vMainUV2\r\n    #else\r\n        varying vec2 vReceiveShadowUV;\r\n    #endif\r\n#endif\r\n#ifdef SHADING_GRADE\r\n    uniform sampler2D shadingGradeSampler;\r\n    #if SHADING_GRADEDIRECTUV == 1\r\n        #define vShadingGradeUV vMainUV1\r\n    #elif SHADING_GRADEDIRECTUV == 2\r\n        #define vShadingGradeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadingGradeUV;\r\n    #endif\r\n#endif\r\n#ifdef RIM\r\n    uniform sampler2D rimSampler;\r\n    #if RIMDIRECTUV == 1\r\n        #define vRimUV vMainUV1\r\n    #elif RIMDIRECTUV == 2\r\n        #define vRimUV vMainUV2\r\n    #else\r\n        varying vec2 vRimUV;\r\n    #endif\r\n#endif\r\n#ifdef MATCAP\r\n    uniform sampler2D matCapSampler;\r\n    #if MATCAPDIRECTUV == 1\r\n        #define vMatCapUV vMainUV1\r\n    #elif MATCAPDIRECTUV == 2\r\n        #define vMatCapUV vMainUV2\r\n    #else\r\n        varying vec2 vMatCapUV;\r\n    #endif\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    uniform sampler2D outlineWidthSampler;\r\n    #if OUTLINE_WIDTHDIRECTUV == 1\r\n        #define vOutlineWidthUV vMainUV1\r\n    #elif OUTLINE_WIDTHDIRECTUV == 2\r\n        #define vOutlineWidthUV vMainUV2\r\n    #else\r\n        varying vec2 vOutlineWidthUV;\r\n    #endif\r\n#endif\r\n#ifdef UV_ANIMATION_MASK\r\n    uniform sampler2D uvAnimationMaskSampler;\r\n    #if UV_ANIMATION_MASKDIRECTUV == 1\r\n        #define vUvAnimationMaskUV vMainUV1\r\n    #elif UV_ANIMATION_MASKDIRECTUV == 2\r\n        #define vUvAnimationMaskUV vMainUV2\r\n    #else\r\n        varying vec2 vUvAnimationMaskUV;\r\n    #endif\r\n#endif\r\n\r\n/**\r\n* DirectionalLight, PointLight の角度を計算\r\n*/\r\nvec3 computeLightDirection(vec4 lightData) {\r\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\r\n}\r\n\r\n/**\r\n* SpotLight の角度を計算\r\n*/\r\nvec3 computeSpotLightDirection(vec4 lightData) {\r\n     return normalize(lightData.xyz - vPositionW);\r\n}\r\n\r\n/**\r\n* HemisphericLight の角度を計算\r\n*/\r\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\r\n     return normalize(lightData.xyz);\r\n}\r\n\r\n/**\r\n* MToon シェーダーの陰実装\r\n*/\r\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\r\n    float _receiveShadow = receiveShadowRate;\r\n#ifdef RECEIVE_SHADOW\r\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\r\n#endif\r\n\r\n    float _shadingGrade = 0.0;\r\n#ifdef SHADING_GRADE\r\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\r\n#endif\r\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\r\n\r\n    // Lighting\r\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\r\n    float _dotNL = dot(lightDirection, worldNormal);\r\n#ifdef MTOON_FORWARD_ADD\r\n    float _lightAttenuation = 1.0;\r\n#else\r\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\r\n#endif\r\n\r\n    // lighting intensity\r\n    float _lightIntensity = _dotNL;\r\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\r\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\r\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\r\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\r\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\r\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\r\n    float _minIntensityThreshold = shadeShift;\r\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\r\n\r\n    // Albedo color\r\n    vec3 _shade = vShadeColor;\r\n#ifdef SHADE\r\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\r\n#endif\r\n\r\n    vec4 _lit = vDiffuseColor;\r\n#ifdef DIFFUSE\r\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\r\n#endif\r\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\r\n\r\n    // Direct Light\r\n    vec3 _lighting = _lightColor;\r\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\r\n#ifdef MTOON_FORWARD_ADD\r\n    _lighting *= 0.5; // darken if additional light\r\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\r\n    _lighting *= shadowAttenuation; // darken if receiving shadow\r\n#else\r\n    // base light does not darken.\r\n#endif\r\n    _col *= _lighting;\r\n\r\n    // Indirect Light\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\r\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\r\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\r\n    _col += _indirectLighting * _lit.rgb;\r\n\r\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\r\n#endif\r\n\r\n    // parametric rim lighting\r\n#ifdef MTOON_FORWARD_ADD\r\n    vec3 _staticRimLighting = vec3(0.0);\r\n    vec3 _mixedRimLighting = _lighting;\r\n#else\r\n    vec3 _staticRimLighting = vec3(1.0);\r\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\r\n#endif\r\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\r\n    vec3 _rimColor = vRimColor.rgb;\r\n#ifdef RIM\r\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\r\n#endif\r\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\r\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\r\n\r\n    // additive matcap\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n#ifdef MATCAP\r\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\r\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\r\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\r\n    // uv.y is reversed\r\n    _matCapUv.y = (1.0 - _matCapUv.y);\r\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\r\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\r\n#endif\r\n#endif\r\n\r\n    // Emission\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n    vec3 _emission = vEmissiveColor.rgb;\r\n#ifdef EMISSIVE\r\n     _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\r\n#endif\r\n     _col += mix(_emission, vec3(0.0), isOutline);\r\n#endif\r\n\r\n    float _alpha = 1.0;\r\n\r\n#if defined(ALPHABLEND) || defined(ALPHATEST)\r\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\r\n#endif\r\n\r\n    // outline\r\n#ifdef MTOON_OUTLINE_COLOR_FIXED\r\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\r\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\r\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\r\n#else\r\n#endif\r\n\r\n    // debug\r\n#ifdef MTOON_DEBUG_NORMAL\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\r\n    #endif\r\n#elif defined(MTOON_DEBUG_LITSHADERATE)\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(_lightIntensity, _lit.a);\r\n    #endif\r\n#endif\r\n\r\n    return vec4(_col, _alpha);\r\n}\r\n\r\n#include<bumpFragmentFunctions>\r\n#include<clipPlaneFragmentDeclaration>\r\n#include<logDepthDeclaration>\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\r\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\r\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\r\n    #else\r\n        discard;\r\n    #endif\r\n#endif\r\n\r\n#include<clipPlaneFragment>\r\n\r\n    vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n    // Base color\r\n    vec4 baseColor = vec4(1., 1., 1., 1.);\r\n    vec3 diffuseColor = vec3(1., 1., 1.);\r\n\r\n    // Alpha\r\n    float alpha = 1.0;\r\n\r\n    // Bump\r\n#ifdef NORMAL\r\n     vec3 normalW = normalize(vNormalW);\r\n#else\r\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\r\n#endif\r\n\r\n#include<depthPrePass>\r\n\r\n    // Ambient color\r\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\r\n    float glossiness = 0.;\r\n\r\n    // Lighting\r\n    vec3 diffuseBase = vec3(0., 0., 0.);\r\n    lightingInfo info;\r\n    float shadow = 1.;\r\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\r\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n    // MToon UV\r\n    // 全てのテクスチャは diffuse(_MainTex) の UV 情報を利用する\r\n    vec2 mainUv = vec2(0.0);\r\n#ifdef DIFFUSE\r\n    mainUv += vDiffuseUV;\r\n#elif defined(MAINUV1)\r\n    mainUv += vMainUV1;\r\n#elif defined(MAINUV2)\r\n    mainUv += vMainUV2;\r\n#endif\r\n\r\n    // uv anim\r\n    float uvAnim = time.y;\r\n#ifdef UV_ANIMATION_MASK\r\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\r\n#endif\r\n    // translate uv in bottom-left origin coordinates.\r\n    // uv is reversed\r\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\r\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\r\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\r\n    vec2 rotatePivot = vec2(0.5, 0.5);\r\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\r\n\r\n#include<mtoonBumpFragment>\r\n\r\n#ifdef TWOSIDEDLIGHTING\r\n    normalW = gl_FrontFacing ? normalW : -normalW;\r\n#endif\r\n\r\n// 通常の lightFragment ではなく、自前実装の mtoonLightFragment を読み込む\r\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\r\n\r\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\r\n\r\n    // Composition\r\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\r\n\r\n    color.rgb = max(color.rgb, 0.);\r\n#include<logDepthFragment>\r\n#include<fogFragment>\r\n\r\n    color.a *= visibility;\r\n\r\n#ifdef PREMULTIPLYALPHA\r\n    // Convert to associative (premultiplied) format if needed.\r\n    color.rgb *= color.a;\r\n#endif\r\n\r\n    gl_FragColor = color;\r\n}\r\n"},function(e,r,t){"use strict";t.r(r);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var i=function(e,r){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var t in r)r.hasOwnProperty(t)&&(e[t]=r[t])})(e,r)};function n(e,r){function t(){this.constructor=e}i(e,r),e.prototype=null===r?Object.create(r):(t.prototype=r.prototype,new t)}function o(e,r,t,i){var n,o=arguments.length,a=o<3?r:null===i?i=Object.getOwnPropertyDescriptor(r,t):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,r,t,i);else for(var s=e.length-1;s>=0;s--)(n=e[s])&&(a=(o<3?n(a):o>3?n(r,t,a):n(r,t))||a);return o>3&&a&&Object.defineProperty(r,t,a),a}var a,s,l,f,d=t(7),u=t(3),h=t(9),c=t(5),p=t(2),m=t(10),v=t(4),g=t(6),_=t(0),M=t(11),b=t(1),T=function(e){function r(){var r=e.call(this)||this;return r.MTOON_OUTLINE_WIDTH_WORLD=!1,r.MTOON_OUTLINE_WIDTH_SCREEN=!1,r.MTOON_OUTLINE_COLOR_FIXED=!1,r.MTOON_OUTLINE_COLOR_MIXED=!1,r.MTOON_DEBUG_NORMAL=!1,r.MTOON_DEBUG_LITSHADERRATE=!1,r.ALPHABLEND=!1,r.NORMAL=!1,r.TANGENT=!1,r.UV1=!1,r.UV2=!1,r.VERTEXALPHA=!1,r.MAINUV1=!1,r.MAINUV2=!1,r.DIFFUSE=!1,r.DIFFUSEDIRECTUV=0,r.EMISSIVE=!1,r.EMISSIVEDIRECTUV=0,r.BUMP=!1,r.BUMPDIRECTUV=0,r.SHADE=!1,r.SHADEDIRECTUV=0,r.RECEIVE_SHADOW=!1,r.RECEIVE_SHADOWDIRECTUV=0,r.SHADING_GRADE=!1,r.SHADING_GRADEDIRECTUV=0,r.RIM=!1,r.RIMDIRECTUV=0,r.MATCAP=!1,r.MATCAPDIRECTUV=0,r.OUTLINE_WIDTH=!1,r.OUTLINE_WIDTHDIRECTUV=0,r.UV_ANIMATION_MASK=!1,r.UV_ANIMATION_MASKDIRECTUV=0,r.MULTIVIEW=!1,r.FOG=!1,r.POINTSIZE=!1,r.LOGARITHMICDEPTH=!1,r.NONUNIFORMSCALING=!1,r.ALPHATEST=!1,r.DEPTHPREPASS=!1,r.NUM_MORPH_INFLUENCERS=0,r.NUM_BONE_INFLUENCERS=0,r.BonesPerMesh=0,r.TWOSIDEDLIGHTING=!1,r.CLIPPLANE=!1,r.CLIPPLANE2=!1,r.CLIPPLANE3=!1,r.CLIPPLANE4=!1,r.CLIPPLANE5=!1,r.CLIPPLANE6=!1,r.BONETEXTURE=!1,r.INSTANCES=!1,r.SHADOWFLOAT=!1,r.MORPHTARGETS=!1,r.MORPHTARGETS_NORMAL=!1,r.MORPHTARGETS_TANGENT=!1,r.PREMULTIPLYALPHA=!1,r.rebuild(),r}return n(r,e),r}(t(12).MaterialDefines),y=t(8),S=function(){function e(r,t){this.scene=r,this.material=t,this._savedDepthWrite=!1,this.name="MToonOutline_"+t.name+"_"+e.rendererId++,this.scene._addComponent(this),this._engine=this.scene.getEngine()}return e.prototype.register=function(){this.scene._beforeRenderingMeshStage.registerStep(y.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(y.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)},e.prototype.rebuild=function(){},e.prototype.dispose=function(){delete this.scene,delete this.material,delete this._engine},e.prototype.render=function(e,r,t){var i=r.effect;i&&i.isReady()&&(this.material.applyOutlineCullMode(),this._engine.enableEffect(i),e._bind(r,i,c.Material.TriangleFillMode),this._engine.setZOffset(-1),e._processRendering(r,i,c.Material.TriangleFillMode,t,this.isHardwareInstancedRendering(r._id,t),(function(t,n,o){o.bindForSubMesh(n,e,r),i.setMatrix("world",n),i.setFloat("isOutline",1)}),this.material),this._engine.setZOffset(0),this.material.restoreOutlineCullMode())},e.prototype._beforeRenderingMesh=function(e,r,t){this._savedDepthWrite=this._engine.getDepthWrite(),this.willRender(r)&&(this._engine.setDepthWrite(!1),this.render(r.getRenderingMesh(),r,t),this._engine.setDepthWrite(this._savedDepthWrite))},e.prototype._afterRenderingMesh=function(e,r,t){this.willRender(r)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(r.getRenderingMesh(),r,t),this._engine.setColorWrite(!0))},e.prototype.isHardwareInstancedRendering=function(e,r){return this._engine.getCaps().instancedArrays&&null!==r.visibleInstances[e]&&void 0!==r.visibleInstances[e]},e.prototype.willRender=function(e){var r=e.getMaterial();return!(!r||"MToonMaterial"!==r.getClassName()||r.getOutlineRendererName()!==this.name)},e.rendererId=0,e}(),I=t(13).default,x=t(14).default,A=t(15).default,O=t(16).default,D=t(17).default,E=t(18).default,C=t(19).default;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(a||(a={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(s||(s={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(l||(l={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(f||(f={}));var U=function(e){function r(r,t){var i,n=e.call(this,r,t)||this;return n._diffuseTexture=null,n.diffuseTexture=null,n._emissiveTexture=null,n.emissiveTexture=null,n._bumpTexture=null,n.bumpTexture=null,n._shadeTexture=null,n.shadeTexture=null,n._receiveShadowTexture=null,n.receiveShadowTexture=null,n._shadingGradeTexture=null,n.shadingGradeTexture=null,n._rimTexture=null,n.rimTexture=null,n._matCapTexture=null,n.matCapTexture=null,n._outlineWidthTexture=null,n.outlineWidthTexture=null,n._uvAnimationMaskTexture=null,n.uvAnimationMaskTexture=null,n.maxSimultaneousLights=16,n.specularSupported=!1,n.useVertexColor=!1,n.useBones=!0,n.useMorphTargets=!0,n.useVertexAlpha=!1,n._useLogarithmicDepth=!1,n._disableLighting=!1,n.disableLighting=!1,n._twoSidedLighting=!1,n.twoSidedLighting=!1,n._alphaCutOff=.5,n.alphaCutOff=.5,n._rebuildInParallel=!1,n.diffuseColor=new v.Color3(1,1,1),n.ambientColor=new v.Color3(.1,.1,.1),n.globalAmbientColor=new v.Color3(0,0,0),n.emissiveColor=new v.Color3(0,0,0),n.shadeColor=new v.Color3(.97,.81,.86),n.rimColor=new v.Color3(0,0,0),n.outlineColor=new v.Color3(0,0,0),n._bumpScale=1,n._receiveShadowRate=1,n._shadingGradeRate=1,n._shadeShift=0,n._shadeToony=.9,n._lightColorAttenuation=0,n._indirectLightIntensity=.1,n._rimLightingMix=0,n._rimFresnelPower=1,n._rimLift=0,n._outlineWidth=.5,n._outlineScaledMaxDistance=1,n._outlineLightingMix=1,n._uvAnimationScrollX=0,n._uvAnimationScrollY=0,n._uvAnimationRotation=0,n._alphaTest=!1,n.alphaTest=!1,n._alphaBlend=!1,n._debugMode=a.None,n.debugMode=a.None,n._outlineWidthMode=l.None,n.outlineColorMode=s.MixedLighting,n._cullMode=f.Back,n._outlineCullMode=f.Front,n.outlineCullMode=f.Front,n.storedCullMode=f.Back,u.Effect.IncludesShadersStore.mtoonUboDeclaration||(u.Effect.IncludesShadersStore.mtoonUboDeclaration=I,u.Effect.IncludesShadersStore.mtoonVertexDeclaration=x,u.Effect.IncludesShadersStore.mtoonFragmentDeclaration=A,u.Effect.IncludesShadersStore.mtoonLightFragment=D,u.Effect.IncludesShadersStore.mtoonBumpFragment=O,u.Effect.ShadersStore.mtoonVertexShader=E,u.Effect.ShadersStore.mtoonFragmentShader=C),n.inspectableCustomProperties=n.inspectableCustomProperties||[],(i=n.inspectableCustomProperties).push.apply(i,[{label:"DiffuseColor",propertyName:"diffuseColor",type:b.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:b.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:b.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:b.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:b.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:b.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:b.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:b.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:b.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:b.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:b.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:b.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:b.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:b.InspectableType.Slider,min:-.5,max:.5,step:.01}]),n}return n(r,e),Object.defineProperty(r.prototype,"appendedTextures",{get:function(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"appendedActiveTextures",{get:function(){return this.appendedTextures.filter((function(e){return null!==e}))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"useLogarithmicDepth",{get:function(){return this._useLogarithmicDepth},set:function(e){var r=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==r&&(this._useLogarithmicDepth=r,this._markAllSubMeshesAsMiscDirty())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"bumpScale",{get:function(){return this._bumpScale},set:function(e){this._bumpScale=e},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"receiveShadowRate",{get:function(){return this._receiveShadowRate},set:function(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadingGradeRate",{get:function(){return this._shadingGradeRate},set:function(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeShift",{get:function(){return this._shadeShift},set:function(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeToony",{get:function(){return this._shadeToony},set:function(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"lightColorAttenuation",{get:function(){return this._lightColorAttenuation},set:function(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"indirectLightIntensity",{get:function(){return this._indirectLightIntensity},set:function(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimLightingMix",{get:function(){return this._rimLightingMix},set:function(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimFresnelPower",{get:function(){return this._rimFresnelPower},set:function(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimLift",{get:function(){return this._rimLift},set:function(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidth",{get:function(){return this._outlineWidth},set:function(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineScaledMaxDistance",{get:function(){return this._outlineScaledMaxDistance},set:function(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineLightingMix",{get:function(){return this._outlineLightingMix},set:function(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"uvAnimationScrollX",{get:function(){return this._uvAnimationScrollX},set:function(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"uvAnimationScrollY",{get:function(){return this._uvAnimationScrollY},set:function(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"uvAnimationRotation",{get:function(){return this._uvAnimationRotation},set:function(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"alphaBlend",{get:function(){return this._alphaBlend},set:function(e){this._alphaBlend=e,e&&(this.backFaceCulling=!0),this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidthMode",{get:function(){return this._outlineWidthMode},set:function(e){this._outlineWidthMode=e,e===l.None||this.outlineRenderer||(this.outlineRenderer=new S(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cullMode",{get:function(){return this._cullMode},set:function(e){switch(this._cullMode=e,this._cullMode){case f.Off:this.backFaceCulling=!1,this.sideOrientation=c.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case f.Front:this.backFaceCulling=!0,this.sideOrientation=c.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case f.Back:this.backFaceCulling=!0,this.sideOrientation=c.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),r.prototype.applyOutlineCullMode=function(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode},r.prototype.restoreOutlineCullMode=function(){this.cullMode=this.storedCullMode},r.prototype.getOutlineRendererName=function(){return this.outlineRenderer?this.outlineRenderer.name:""},r.prototype.isReadyForSubMesh=function(e,r,t){if(void 0===t&&(t=!1),r.effect&&this.isFrozen&&r.effect._wasPreviouslyReady)return!0;r._materialDefines||(r._materialDefines=new T);var i=this.getScene(),n=r._materialDefines;if(!this.checkReadyOnEveryCall&&r.effect&&n._renderId===i.getRenderId())return!0;var o=i.getEngine();if(n._needNormals=p.MaterialHelper.PrepareDefinesForLights(i,e,n,this.specularSupported,this.maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==l.None&&(n._needNormals=!0),this.applyDefines(n),p.MaterialHelper.PrepareDefinesForMultiview(i,n),n._areTexturesDirty){if(n._needUVs=!1,n.MAINUV1=!1,n.MAINUV2=!1,i.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,n,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,n,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,n,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,n,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,n,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,n,"RIM")&&this.isReadyForTexture(this._matCapTexture,n,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,n,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,n,"UV_ANIMATION_MASK")))return!1;if(i.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;p.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,n,"BUMP")}else n.BUMP=!1;n.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else n.DIFFUSE=!1,n.EMISSIVE=!1,n.SHADE=!1,n.RECEIVE_SHADOW=!1,n.SHADING_GRADE=!1,n.RIM=!1,n.MATCAP=!1,n.OUTLINE_WIDTH=!1,n.BUMP=!1,n.UV_ANIMATION_MASK=!1;n.PREMULTIPLYALPHA=this.alphaMode===d.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===d.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF}if(p.MaterialHelper.PrepareDefinesForMisc(e,i,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e),n),p.MaterialHelper.PrepareDefinesForAttributes(e,n,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),p.MaterialHelper.PrepareDefinesForFrameBoundValues(i,o,n,t),n.isDirty){var a=n._areLightsDisposed;n.markAsProcessed();var s=new h.EffectFallbacks;n.BUMP&&s.addFallback(0,"BUMP"),n.FOG&&s.addFallback(1,"FOG"),n.POINTSIZE&&s.addFallback(0,"POINTSIZE"),n.LOGARITHMICDEPTH&&s.addFallback(0,"LOGARITHMICDEPTH"),p.MaterialHelper.HandleFallbacksForShadows(n,s,this.maxSimultaneousLights),n.MULTIVIEW&&s.addFallback(0,"MULTIVIEW");var f=[g.VertexBuffer.PositionKind];n.NORMAL&&f.push(g.VertexBuffer.NormalKind),n.TANGENT&&f.push(g.VertexBuffer.TangentKind),n.UV1&&f.push(g.VertexBuffer.UVKind),n.UV2&&f.push(g.VertexBuffer.UV2Kind),p.MaterialHelper.PrepareAttributesForBones(f,e,n,s),p.MaterialHelper.PrepareAttributesForInstances(f,n),p.MaterialHelper.PrepareAttributesForMorphTargets(f,e,n);var u=["world","view","viewProjection","vLightsType","visibility","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","vFogInfos","vFogColor","pointSize","alphaCutOff","logarithmicDepthConstant","vTangentSpaceParams","boneTextureWidth","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyePosition","vEyeUp","time"],c=["diffuseSampler","emissiveSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],m=["Material","Scene"];p.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:u,uniformBuffersNames:m,samplers:c,defines:n,maxSimultaneousLights:this.maxSimultaneousLights}),this.applyDefines(n);var v=n.toString(),_=r.effect,M=i.getEngine().createEffect("mtoon",{attributes:f,uniformsNames:u,uniformBuffersNames:m,samplers:c,defines:v,fallbacks:s,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this.maxSimultaneousLights,maxSimultaneousMorphTargets:n.NUM_MORPH_INFLUENCERS}},o);if(M)if(this.allowShaderHotSwapping&&_&&!M.isReady()){if(M=_,this._rebuildInParallel=!0,n.markAsUnprocessed(),a)return n._areLightsDisposed=!0,!1}else this._rebuildInParallel=!1,i.resetCachedMaterial(),r.setEffect(M,n),this.buildUniformLayout()}return!(!r.effect||!r.effect.isReady()||(n._renderId=i.getRenderId(),r.effect._wasPreviouslyReady=!0,0))},r.prototype.bindForSubMesh=function(e,r,t){var i=this.getScene(),n=t._materialDefines,o=t.effect;if(n&&o){this._activeEffect=o,this.bindOnlyWorldMatrix(e),p.MaterialHelper.BindBonesParameters(r,o);var a=i.isCachedMaterialInvalid(this,o,r.visibility);if(a){if(this._uniformBuffer.bindToEffect(o,"Material"),this.bindViewProjection(o),(!this._uniformBuffer.useUbo||!this.isFrozen||!this._uniformBuffer.isSync)&&i.texturesEnabled){if(this.bindTexture(this._diffuseTexture,o,"diffuse","vDiffuseInfos"),o.setFloat("alphaCutOff",this._alphaCutOff),this.bindTexture(this._emissiveTexture,o,"emissive","vEmissiveInfos"),this._bumpTexture){this._uniformBuffer.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale);var s=this._bumpTexture.getTextureMatrix();s.isIdentityAs3x2()||this._uniformBuffer.updateMatrix("bumpMatrix",s),o.setTexture("bumpSampler",this._bumpTexture),i._mirroredCameraPosition?this._uniformBuffer.updateFloat2("vTangentSpaceParams",1,1):this._uniformBuffer.updateFloat2("vTangentSpaceParams",-1,-1)}this.bindTexture(this._shadeTexture,o,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,o,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,o,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,o,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,o,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,o,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,o,"uvAnimationMask","vUvAnimationMaskInfos")}this.pointsCloud&&this._uniformBuffer.updateFloat("pointSize",this.pointSize),this._uniformBuffer.updateFloat("visibility",r.visibility),this._uniformBuffer.updateFloat("receiveShadowRate",this._receiveShadowRate),this._uniformBuffer.updateFloat("shadingGradeRate",this._shadingGradeRate),this._uniformBuffer.updateFloat("shadeShift",this._shadeShift),this._uniformBuffer.updateFloat("shadeToony",this._shadeToony),this._uniformBuffer.updateFloat("lightColorAttenuation",this._lightColorAttenuation),this._uniformBuffer.updateFloat("indirectLightIntensity",this._indirectLightIntensity),this._uniformBuffer.updateFloat("rimLightingMix",this._rimLightingMix),this._uniformBuffer.updateFloat("rimFresnelPower",this._rimFresnelPower),this._uniformBuffer.updateFloat("rimLift",this._rimLift),this._uniformBuffer.updateFloat("outlineWidth",this._outlineWidth),this._uniformBuffer.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),this._uniformBuffer.updateFloat("outlineLightingMix",this._outlineLightingMix),this._uniformBuffer.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),this._uniformBuffer.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),this._uniformBuffer.updateFloat("uvAnimationRotation",this._uvAnimationRotation),p.MaterialHelper.BindClipPlane(o,i),i.ambientColor.multiplyToRef(this.ambientColor,this.globalAmbientColor),o.setColor3("vAmbientColor",this.globalAmbientColor),this._uniformBuffer.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),this._uniformBuffer.updateColor3("vEmissiveColor",this.emissiveColor),this._uniformBuffer.updateColor3("vShadeColor",this.shadeColor),this._uniformBuffer.updateColor3("vRimColor",this.rimColor),this._uniformBuffer.updateColor4("vOutlineColor",this.outlineColor,1),p.MaterialHelper.BindEyePosition(o,i),o.setVector3("vEyeUp",i.activeCamera.upVector)}!a&&this.isFrozen||(i.lightsEnabled&&!this.disableLighting&&p.MaterialHelper.BindLights(i,r,o,n,this.maxSimultaneousLights,this._rebuildInParallel),i.fogEnabled&&r.applyFog&&i.fogMode!==M.Scene.FOGMODE_NONE&&this.bindView(o),p.MaterialHelper.BindFogParameters(i,r,o),n.NUM_MORPH_INFLUENCERS&&p.MaterialHelper.BindMorphTargetParameters(r,o),this.useLogarithmicDepth&&p.MaterialHelper.BindLogDepth(n,o,i)),o.setFloat("aspect",i.getEngine().getAspectRatio(i.activeCamera)),o.setFloat("isOutline",0);var l=window.performance.now()/1e3;o.setVector4("time",new v.Vector4(l/20,l,2*l,3*l)),this._uniformBuffer.update(),this._afterBind(r,this._activeEffect)}},r.prototype.getAnimatables=function(){for(var e=[],r=0,t=this.appendedActiveTextures;r<t.length;r++){var i=t[r];i.animations&&i.animations.length>0&&e.push(i)}return e},r.prototype.getActiveTextures=function(){return e.prototype.getActiveTextures.call(this).concat(this.appendedActiveTextures)},r.prototype.hasTexture=function(r){return!!e.prototype.hasTexture.call(this,r)||this.appendedActiveTextures.length>0},r.prototype.dispose=function(r,t,i){if(delete this.outlineRenderer,t)for(var n=0,o=this.appendedActiveTextures;n<o.length;n++)o[n].dispose();e.prototype.dispose.call(this,r,t,i)},r.prototype.buildUniformLayout=function(){this._uniformBuffer.addUniform("vDiffuseColor",4),this._uniformBuffer.addUniform("vDiffuseInfos",2),this._uniformBuffer.addUniform("diffuseMatrix",16),this._uniformBuffer.addUniform("vEmissiveColor",3),this._uniformBuffer.addUniform("vEmissiveInfos",2),this._uniformBuffer.addUniform("emissiveMatrix",16),this._uniformBuffer.addUniform("vBumpInfos",3),this._uniformBuffer.addUniform("bumpMatrix",16),this._uniformBuffer.addUniform("vShadeColor",3),this._uniformBuffer.addUniform("vShadeInfos",2),this._uniformBuffer.addUniform("shadeMatrix",16),this._uniformBuffer.addUniform("vReceiveShadowInfos",2),this._uniformBuffer.addUniform("receiveShadowMatrix",16),this._uniformBuffer.addUniform("vShadingGradeInfos",2),this._uniformBuffer.addUniform("shadingGradeMatrix",16),this._uniformBuffer.addUniform("vRimColor",3),this._uniformBuffer.addUniform("vRimInfos",2),this._uniformBuffer.addUniform("rimMatrix",16),this._uniformBuffer.addUniform("vMatCapInfos",2),this._uniformBuffer.addUniform("matCapMatrix",16),this._uniformBuffer.addUniform("vOutlineColor",3),this._uniformBuffer.addUniform("vOutlineWidthInfos",2),this._uniformBuffer.addUniform("outlineWidthMatrix",16),this._uniformBuffer.addUniform("vUvAnimationMaskInfos",2),this._uniformBuffer.addUniform("uvAnimationMaskMatrix",16),this._uniformBuffer.addUniform("vTangentSpaceParams",2),this._uniformBuffer.addUniform("pointSize",1),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.addUniform("shadingGradeRate",1),this._uniformBuffer.addUniform("receiveShadowRate",1),this._uniformBuffer.addUniform("shadeShift",1),this._uniformBuffer.addUniform("shadeToony",1),this._uniformBuffer.addUniform("lightColorAttenuation",1),this._uniformBuffer.addUniform("indirectLightIntensity",1),this._uniformBuffer.addUniform("rimLightingMix",1),this._uniformBuffer.addUniform("rimFresnelPower",1),this._uniformBuffer.addUniform("rimLift",1),this._uniformBuffer.addUniform("outlineWidth",1),this._uniformBuffer.addUniform("outlineScaledMaxDistance",1),this._uniformBuffer.addUniform("outlineLightingMix",1),this._uniformBuffer.addUniform("uvAnimationScrollX",1),this._uniformBuffer.addUniform("uvAnimationScrollY",1),this._uniformBuffer.addUniform("uvAnimationRotation",1),this._uniformBuffer.create()},r.prototype.bindTexture=function(e,r,t,i){if(e){this._uniformBuffer.updateFloat2(i,e.coordinatesIndex,e.level);var n=e.getTextureMatrix();n.isIdentityAs3x2()||this._uniformBuffer.updateMatrix(t+"Matrix",n),r.setTexture(t+"Sampler",e)}},r.prototype.isReadyForTexture=function(e,r,t){return e?!!e.isReadyOrNotBlocking()&&(p.MaterialHelper.PrepareDefinesForMergedUV(e,r,t),!0):(r[t]=!1,!0)},r.prototype.applyDefines=function(e){switch(this._alphaBlend!==e.ALPHABLEND&&(e.ALPHABLEND=this._alphaBlend,e.markAsUnprocessed()),this._debugMode){case a.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case a.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case a.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case l.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case l.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case l.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case s.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case s.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}},r.prototype.getClassName=function(){return"MToonMaterial"},r.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},r.prototype.needAlphaBlending=function(){return this._alphaBlend},r.prototype.needAlphaTesting=function(){return this._alphaTest},r.prototype.clone=function(e){var t=this,i=_.SerializationHelper.Clone((function(){return new r(e,t.getScene())}),this);return i.name=e,i.id=e,i},r.prototype.serialize=function(){return _.SerializationHelper.Serialize(this)},r.Parse=function(e,t,i){return _.SerializationHelper.Parse((function(){return new r(e.name,t)}),e,t,i)},o([Object(_.serializeAsTexture)("diffuseTexture")],r.prototype,"_diffuseTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],r.prototype,"diffuseTexture",void 0),o([Object(_.serializeAsTexture)("emissiveTexture")],r.prototype,"_emissiveTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"emissiveTexture",void 0),o([Object(_.serializeAsTexture)("bumpTexture")],r.prototype,"_bumpTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"bumpTexture",void 0),o([Object(_.serializeAsTexture)("shadeTexture")],r.prototype,"_shadeTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadeTexture",void 0),o([Object(_.serializeAsTexture)("receiveShadowTexture")],r.prototype,"_receiveShadowTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"receiveShadowTexture",void 0),o([Object(_.serializeAsTexture)("shadingGradeTexture")],r.prototype,"_shadingGradeTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadingGradeTexture",void 0),o([Object(_.serializeAsTexture)("rimTexture")],r.prototype,"_rimTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"rimTexture",void 0),o([Object(_.serializeAsTexture)("matCapTexture")],r.prototype,"_matCapTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"matCapTexture",void 0),o([Object(_.serializeAsTexture)("outlineWidthTexture")],r.prototype,"_outlineWidthTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"outlineWidthTexture",void 0),o([Object(_.serializeAsTexture)("outlineWidthTexture")],r.prototype,"_uvAnimationMaskTexture",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"uvAnimationMaskTexture",void 0),o([Object(_.serialize)()],r.prototype,"useLogarithmicDepth",null),o([Object(_.serialize)("disableLighting")],r.prototype,"_disableLighting",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"disableLighting",void 0),o([Object(_.serialize)("twoSidedLighting")],r.prototype,"_twoSidedLighting",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"twoSidedLighting",void 0),o([Object(_.serialize)("alphaCutOff")],r.prototype,"_alphaCutOff",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"alphaCutOff",void 0),o([Object(_.serializeAsColor3)("diffuse")],r.prototype,"diffuseColor",void 0),o([Object(_.serialize)("ambient")],r.prototype,"ambientColor",void 0),o([Object(_.serialize)("emissive")],r.prototype,"emissiveColor",void 0),o([Object(_.serialize)("shade")],r.prototype,"shadeColor",void 0),o([Object(_.serialize)("rim")],r.prototype,"rimColor",void 0),o([Object(_.serialize)("outline")],r.prototype,"outlineColor",void 0),o([Object(_.serialize)()],r.prototype,"bumpScale",null),o([Object(_.serialize)()],r.prototype,"receiveShadowRate",null),o([Object(_.serialize)()],r.prototype,"shadingGradeRate",null),o([Object(_.serialize)()],r.prototype,"shadeShift",null),o([Object(_.serialize)()],r.prototype,"shadeToony",null),o([Object(_.serialize)()],r.prototype,"lightColorAttenuation",null),o([Object(_.serialize)()],r.prototype,"indirectLightIntensity",null),o([Object(_.serialize)()],r.prototype,"rimLightingMix",null),o([Object(_.serialize)()],r.prototype,"rimFresnelPower",null),o([Object(_.serialize)()],r.prototype,"rimLift",null),o([Object(_.serialize)()],r.prototype,"outlineWidth",null),o([Object(_.serialize)()],r.prototype,"outlineScaledMaxDistance",null),o([Object(_.serialize)()],r.prototype,"outlineLightingMix",null),o([Object(_.serialize)()],r.prototype,"uvAnimationScrollX",null),o([Object(_.serialize)()],r.prototype,"uvAnimationScrollY",null),o([Object(_.serialize)()],r.prototype,"uvAnimationRotation",null),o([Object(_.serialize)("alphaTest")],r.prototype,"_alphaTest",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"alphaTest",void 0),o([Object(_.serialize)()],r.prototype,"alphaBlend",null),o([Object(_.serialize)("debugMode")],r.prototype,"_debugMode",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"debugMode",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineColorMode",void 0),o([Object(_.serialize)()],r.prototype,"cullMode",null),o([Object(_.serialize)()],r.prototype,"_outlineCullMode",void 0),o([Object(_.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineCullMode",void 0),r}(m.PushMaterial);t.d(r,"DebugMode",(function(){return a})),t.d(r,"OutlineColorMode",(function(){return s})),t.d(r,"OutlineWidthMode",(function(){return l})),t.d(r,"CullMode",(function(){return f})),t.d(r,"MToonMaterial",(function(){return U}))}]))},function(e,r){e.exports=i},function(e,r){e.exports=n},function(e,r){e.exports=o},function(e,r){e.exports=a},function(e,r){e.exports=s},function(e,r){e.exports=l},function(e,r){e.exports=f},function(e,r){e.exports=d},function(e,r){e.exports=u},function(e,r){e.exports=h},function(e,r){e.exports=c},function(e,r){e.exports=p},function(e,r){e.exports=m},function(e,r){e.exports=v},function(e,r,t){"use strict";t.r(r),t.d(r,"VCAST_vci_material_unity",(function(){return c})),t.d(r,"VRM",(function(){return m})),t.d(r,"VRMFileLoader",(function(){return g})),t.d(r,"IVRMMaterialPropertyShader",(function(){return s})),t.d(r,"VRMManager",(function(){return p})),t.d(r,"VRMMaterialGenerator",(function(){return u}));var i=t(1),n=function(e,r){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var t in r)r.hasOwnProperty(t)&&(e[t]=r[t])})(e,r)};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function o(e,r,t,i){return new(t||(t=Promise))((function(n,o){function a(e){try{l(i.next(e))}catch(e){o(e)}}function s(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var r;e.done?n(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(a,s)}l((i=i.apply(e,r||[])).next())}))}function a(e,r){var t,i,n,o,a={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,i&&(n=2&o[0]?i.return:o[0]?i.throw||((n=i.return)&&n.call(i),0):i.next)&&!(n=n.call(i,o[1])).done)return n;switch(i=0,n&&(o=[2&o[0],n.value]),o[0]){case 0:case 1:n=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,i=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(n=a.trys,(n=n.length>0&&n[n.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!n||o[1]>n[0]&&o[1]<n[3])){a.label=o[1];break}if(6===o[0]&&a.label<n[1]){a.label=n[1],n=o;break}if(n&&a.label<n[2]){a.label=n[2],a.ops.push(o);break}n[2]&&a.ops.pop(),a.trys.pop();continue}o=r.call(e,a)}catch(e){o=[6,e],i=0}finally{t=n=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}}var s,l=t(0),f=t(3);!function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(s||(s={}));var d=t(2),u=function(){function e(e){this.loader=e}return e.prototype.generate=function(e,r,t,i,n){var o=this.getMaterialProperties();if(!o)return null;var a=this.findMaterialPropertyByName(r.name,o);if(!a)return null;var s=this.createMaterialByShader(e,r,i,a);return s?(n(s),s instanceof f.MToonMaterial?(t.alphaIndex=a.renderQueue,this.loadMToonTexturesAsync(e,s,a)):Promise.resolve(s)):null},e.prototype.getMaterialProperties=function(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:null:null},e.prototype.loadMToonTexturesAsync=function(r,t,i){return o(this,void 0,void 0,(function(){var n,o,s,l,f,d,u;return a(this,(function(a){for(n=[],o=0,s=Object.keys(e.TEXTURE_MAP);o<s.length;o++)l=s[o],void 0!==(f=i.textureProperties[l])&&(d=e.TEXTURE_MAP[l],u=function(e,r){return function(i){var n=i;r&&(n.uOffset=r[0],n.vOffset=r[1],n.uScale=r[2],n.vScale=r[3]),t[e]=n}}(d,i.vectorProperties[l]),n.push(this.loader.loadTextureInfoAsync(r,{index:f,texCoord:0},u)));return[2,Promise.all(n).then((function(){return t}))]}))}))},e.prototype.createMaterialByShader=function(e,r,t,i){if(i.shader===s.VRMMToon){var n=new f.MToonMaterial(r.name||"material"+r.index,this.loader.babylonScene);return this.setMToonMaterialProperties(n,i),n}if(i.shader===s.VRMUnlitTransparentZWrite){var o=this.loader.createMaterial(e,r,t);return o.disableDepthWrite=!1,o.forceDepthWrite=!0,o}return null},e.prototype.findMaterialPropertyByName=function(e,r){if(!e||!r)return null;var t=r.filter((function(r){return r.name===e}));return 0===t.length?null:(t.length>=2&&this.loader.log("Duplicated name found"+e),t[t.length-1])},e.prototype.setMToonMaterialProperties=function(e,r){if(void 0!==r.floatProperties._DebugMode&&(e.debugMode=r.floatProperties._DebugMode),void 0!==r.floatProperties._OutlineWidthMode&&(e.outlineWidthMode=r.floatProperties._OutlineWidthMode),void 0!==r.floatProperties._OutlineColorMode&&(e.outlineColorMode=r.floatProperties._OutlineColorMode),void 0!==r.floatProperties._CullMode&&(e.cullMode=r.floatProperties._CullMode),void 0!==r.floatProperties._OutlineCullMode&&(e.outlineCullMode=r.floatProperties._OutlineCullMode),void 0!==r.floatProperties._Cutoff&&(e.alphaCutOff=r.floatProperties._Cutoff),void 0!==r.vectorProperties._Color&&(e.diffuseColor=new l.Color3(r.vectorProperties._Color[0],r.vectorProperties._Color[1],r.vectorProperties._Color[2]),e.alpha=r.vectorProperties._Color[3]),void 0!==r.vectorProperties._ShadeColor&&(e.shadeColor=new l.Color3(r.vectorProperties._ShadeColor[0],r.vectorProperties._ShadeColor[1],r.vectorProperties._ShadeColor[2])),void 0!==r.floatProperties._BumpScale&&(e.bumpScale=r.floatProperties._BumpScale),void 0!==r.floatProperties._ReceiveShadowRate&&(e.receiveShadowRate=r.floatProperties._ReceiveShadowRate),void 0!==r.floatProperties._ShadingGradeRate&&(e.shadingGradeRate=r.floatProperties._ShadingGradeRate),void 0!==r.floatProperties._ShadeShift&&(e.shadeShift=r.floatProperties._ShadeShift),void 0!==r.floatProperties._ShadeToony&&(e.shadeToony=r.floatProperties._ShadeToony),void 0!==r.floatProperties._LightColorAttenuation&&(e.lightColorAttenuation=r.floatProperties._LightColorAttenuation),void 0!==r.floatProperties._IndirectLightIntensity&&(e.indirectLightIntensity=r.floatProperties._IndirectLightIntensity),void 0!==r.vectorProperties._EmissionColor&&(e.emissiveColor=new l.Color3(r.vectorProperties._EmissionColor[0],r.vectorProperties._EmissionColor[1],r.vectorProperties._EmissionColor[2])),void 0!==r.floatProperties._OutlineWidth&&(e.outlineWidth=r.floatProperties._OutlineWidth),void 0!==r.floatProperties._OutlineScaledMaxDistance&&(e.outlineScaledMaxDistance=r.floatProperties._OutlineScaledMaxDistance),void 0!==r.vectorProperties._OutlineColor&&(e.outlineColor=new l.Color3(r.vectorProperties._OutlineColor[0],r.vectorProperties._OutlineColor[1],r.vectorProperties._OutlineColor[2])),void 0!==r.floatProperties._OutlineLightingMix&&(e.outlineLightingMix=r.floatProperties._OutlineLightingMix),void 0!==r.floatProperties._BlendMode)switch(r.floatProperties._BlendMode){case 0:e.alphaBlend=!1,e.alphaTest=!1,e.alphaMode=d.Engine.ALPHA_DISABLE;break;case 1:e.alphaBlend=!1,e.alphaTest=!0,e.alphaMode=d.Engine.ALPHA_COMBINE;break;case 2:e.alphaBlend=!0,e.alphaTest=!1,e.alphaMode=d.Engine.ALPHA_COMBINE}void 0!==r.keywordMap._ALPHABLEND_ON&&(e.alphaBlend=r.keywordMap._ALPHABLEND_ON),void 0!==r.keywordMap._ALPHATEST_ON&&(e.alphaTest=r.keywordMap._ALPHATEST_ON),void 0!==r.floatProperties._ZWrite&&(e.forceDepthWrite=1===r.floatProperties._ZWrite,e.forceDepthWrite&&(e.disableDepthWrite=!1))},e.TEXTURE_MAP={_MainTex:"diffuseTexture",_ShadeTexture:"shadeTexture",_EmissionMap:"emissiveTexture",_BumpMap:"bumpTexture",_ReceiveShadowTexture:"receiveShadowTexture",_ShadingGradeTexture:"shadingGradeTexture",_SphereAdd:"matCapTexture",_OutlineWidthTexture:"outlineWidthTexture"},e}(),h="VCAST_vci_material_unity",c=function(){function e(e){this.loader=e,this.name=h,this.enabled=!0}return e.prototype.dispose=function(){delete this.loader},e.prototype._loadMaterialAsync=function(e,r,t,i,n){return new u(this.loader).generate(e,r,t,i,n)},e}();i.GLTFLoader.RegisterExtension(h,(function(e){return new c(e)}));var p=function(){function e(e,r,t,i){this.ext=e,this.scene=r,this.meshesFrom=t,this.transformNodesFrom=i,this.morphTargetMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache=null,this.constructMorphTargetMap(),this.constructTransformNodeMap()}return e.prototype.dispose=function(){this.morphTargetMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache=null},e.prototype.morphing=function(e,r){if(!this.morphTargetMap[e])throw new Error("Unknown morph label "+e);this.morphTargetMap[e].forEach((function(e){e.target.influence=Math.max(0,Math.min(1,r))*(e.weight/100)}))},e.prototype.morphingPreset=function(e,r){if(!this.presetMorphTargetMap[e])throw new Error("Unknown preset morph label "+e);this.presetMorphTargetMap[e].forEach((function(e){e.target.influence=Math.max(0,Math.min(1,r))*(e.weight/100)}))},e.prototype.getBone=function(e){return this.transformNodeMap[e]||null},e.prototype.constructMorphTargetMap=function(){var e=this;this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&this.ext.blendShapeMaster.blendShapeGroups.forEach((function(r){r.binds&&r.binds.forEach((function(t){var i=e.findMesh(t.mesh);if(i){var n=i.morphTargetManager;if(n){var o=n.getTarget(t.index);e.morphTargetMap[r.name]=e.morphTargetMap[r.name]||[],e.morphTargetMap[r.name].push({target:o,weight:t.weight}),r.presetName&&(e.presetMorphTargetMap[r.presetName]=e.morphTargetMap[r.presetName]||[],e.presetMorphTargetMap[r.presetName].push({target:o,weight:t.weight}))}else console.log("Undefined morphTargetManager",t)}else console.log("Undefined BlendShapeBind Mesh",t)}))}))},e.prototype.constructTransformNodeMap=function(){var e=this;this.ext.humanoid.humanBones.forEach((function(r){var t=e.findTransformNode(r.node);t&&(e.transformNodeMap[r.bone]=t)}))},e.prototype.findTransformNode=function(e){var r=this;return this.transformNodeCache||(this.transformNodeCache=this.scene.transformNodes.filter((function(e,t){return t>=r.transformNodesFrom&&!!e.metadata&&!!e.metadata.gltf&&!!e.metadata.gltf.pointers&&0!==e.metadata.gltf.pointers.length})).reduce((function(e,r){for(var t=-1,i=0,n=r.metadata.gltf.pointers;i<n.length;i++){var o=n[i];o.startsWith("/nodes/")&&(t=parseInt(o.substr(7),10))}return-1!==t&&(e[t]=r),e}),{})),this.transformNodeCache[e]||null},e.prototype.findMesh=function(e){var r=this,t=this.scene.meshes.find((function(t,i){if(i<r.meshesFrom||!t.metadata||!t.metadata.gltf||!t.metadata.gltf.pointers||t.metadata.gltf.pointers.length<1)return!1;for(var n=0,o=t.metadata.gltf.pointers;n<o.length;n++){if(o[n].startsWith("/meshes/"+e))return!0}return!1}));return t||null},e}(),m=function(){function e(e){this.loader=e,this.name="VRM",this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.meshesFrom=this.loader.babylonScene.meshes.length,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length}return e.prototype.dispose=function(){delete this.loader},e.prototype.onReady=function(){var e=this;if(this.loader.gltf.extensions&&this.loader.gltf.extensions.VRM){var r=this.loader.babylonScene,t=new p(this.loader.gltf.extensions.VRM,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom);r.metadata=r.metadata||{},r.metadata.vrmManagers=r.metadata.vrmManagers||[],r.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((function(){t.dispose(),e.loader.babylonScene.metadata.vrmManagers=[]}))}},e.prototype._loadVertexDataAsync=function(e,r,t){return r.extras&&r.extras.targetNames?(t.metadata=t.metadata||{},t.metadata.vrmTargetNames=r.extras.targetNames,null):null},e.prototype._loadMaterialAsync=function(e,r,t,i,n){return new u(this.loader).generate(e,r,t,i,n)},e}();i.GLTFLoader.RegisterExtension("VRM",(function(e){return new m(e)}));var v=t(4),g=function(e){function r(){var r=null!==e&&e.apply(this,arguments)||this;return r.name="vrm",r.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}},r}return function(e,r){function t(){this.constructor=e}n(e,r),e.prototype=null===r?Object.create(r):(t.prototype=r.prototype,new t)}(r,e),r.prototype.createPlugin=function(){return new r},r}(t(5).GLTFFileLoader);v.SceneLoader&&v.SceneLoader.RegisterPlugin(new g)}])}));